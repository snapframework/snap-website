<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Snap.Types</title><link href="haddock.css" rel="stylesheet" type="text/css" title="haddock" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Snap-Types.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Snap-Types.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">snap-core-0.5.1: Snap: A Haskell Web Framework (Core)</p></div><div id="content"><div id="module-header"><p class="caption">Snap.Types</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The Snap Monad
</a><ul><li><a href="#g:2">Functions for control flow and early termination
</a></li><li><a href="#g:3">Routing
</a></li><li><a href="#g:4">Access to state
</a></li><li><a href="#g:5">Logging
</a></li><li><a href="#g:6">Grabbing/transforming request bodies
</a></li></ul></li><li><a href="#g:7">HTTP Datatypes and Functions
</a><ul><li><a href="#g:8">Headers
</a></li><li><a href="#g:9">Requests
</a></li><li><a href="#g:10">Responses
</a><ul><li><a href="#g:11">Response I/O
</a></li></ul></li><li><a href="#g:12">Timeouts
</a></li></ul></li><li><a href="#g:13">Iteratee
</a></li><li><a href="#g:14">HTTP utilities
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the core type definitions, class instances, and functions
for HTTP as well as the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad, which is used for web handlers.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Snap">Snap</a> a</li><li class="src short"><a href="#v:runSnap">runSnap</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; (<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>) -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Snap-Types.html#t:Request">Request</a>, <a href="Snap-Types.html#t:Response">Response</a>)</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Monad">Monad</a> m, MonadIO m, <a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:MonadCatchIO">MonadCatchIO</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus">MonadPlus</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Functor">Functor</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative">Alternative</a> m) =&gt; <a href="#t:MonadSnap">MonadSnap</a> m  <span class="keyword">where</span><ul class="subs"><li><a href="#v:liftSnap">liftSnap</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; m a</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:NoHandlerException">NoHandlerException</a>  = <a href="#v:NoHandlerException">NoHandlerException</a></li><li class="src short"><a href="#v:bracketSnap">bracketSnap</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> b) -&gt; (a -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> c) -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> c</li><li class="src short"><a href="#v:finishWith">finishWith</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; m a</li><li class="src short"><a href="#v:catchFinishWith">catchFinishWith</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Snap-Types.html#t:Response">Response</a> a)</li><li class="src short"><a href="#v:pass">pass</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m a</li><li class="src short"><a href="#v:method">method</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Method">Method</a> -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:methods">methods</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [<a href="Snap-Types.html#t:Method">Method</a>] -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:path">path</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:pathArg">pathArg</a> :: (<a href="Snap-Util-Readable.html#t:Readable">Readable</a> a, <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m) =&gt; (a -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:dir">dir</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:ifTop">ifTop</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m a -&gt; m a</li><li class="src short"><a href="#v:route">route</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [(<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>, m a)] -&gt; m a</li><li class="src short"><a href="#v:routeLocal">routeLocal</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [(<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>, m a)] -&gt; m a</li><li class="src short"><a href="#v:getRequest">getRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Request">Request</a></li><li class="src short"><a href="#v:getResponse">getResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:putRequest">putRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:putResponse">putResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:modifyRequest">modifyRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:modifyResponse">modifyResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:localRequest">localRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a>) -&gt; m a -&gt; m a</li><li class="src short"><a href="#v:withRequest">withRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; m a) -&gt; m a</li><li class="src short"><a href="#v:withResponse">withResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Response">Response</a> -&gt; m a) -&gt; m a</li><li class="src short"><a href="#v:logError">logError</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:runRequestBody">runRequestBody</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; m a</li><li class="src short"><a href="#v:getRequestBody">getRequestBody</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:transformRequestBody">transformRequestBody</a> :: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Request">Request</a> </li><li class="src short"><span class="keyword">data</span>  <a href="#t:Response">Response</a> </li><li class="src short"><span class="keyword">type</span> <a href="#t:Headers">Headers</a> = <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t:Map">Map</a> (<a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>) [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li class="src short"><span class="keyword">class</span>  <a href="#t:HasHeaders">HasHeaders</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:updateHeaders">updateHeaders</a> :: (<a href="Snap-Types.html#t:Headers">Headers</a> -&gt; <a href="Snap-Types.html#t:Headers">Headers</a>) -&gt; a -&gt; a</li><li><a href="#v:headers">headers</a> :: a -&gt; <a href="Snap-Types.html#t:Headers">Headers</a></li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Params">Params</a> = <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Method">Method</a> <ul class="subs"><li>= <a href="#v:GET">GET</a>  </li><li>| <a href="#v:HEAD">HEAD</a>  </li><li>| <a href="#v:POST">POST</a>  </li><li>| <a href="#v:PUT">PUT</a>  </li><li>| <a href="#v:DELETE">DELETE</a>  </li><li>| <a href="#v:TRACE">TRACE</a>  </li><li>| <a href="#v:OPTIONS">OPTIONS</a>  </li><li>| <a href="#v:CONNECT">CONNECT</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Cookie">Cookie</a>  = <a href="#v:Cookie">Cookie</a> {<ul class="subs"><li><a href="#v:cookieName">cookieName</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li><a href="#v:cookieValue">cookieValue</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li><a href="#v:cookieExpires">cookieExpires</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime">UTCTime</a>)</li><li><a href="#v:cookieDomain">cookieDomain</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li><a href="#v:cookiePath">cookiePath</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:HttpVersion">HttpVersion</a> = (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:addHeader">addHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:setHeader">setHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:getHeader">getHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:deleteHeader">deleteHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:ipHeaderFilter">ipHeaderFilter</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:ipHeaderFilter-39-">ipHeaderFilter'</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:rqServerName">rqServerName</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqServerPort">rqServerPort</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rqRemoteAddr">rqRemoteAddr</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqRemotePort">rqRemotePort</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rqLocalAddr">rqLocalAddr</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqLocalHostname">rqLocalHostname</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqIsSecure">rqIsSecure</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:rqContentLength">rqContentLength</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rqMethod">rqMethod</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Method">Method</a></li><li class="src short"><a href="#v:rqVersion">rqVersion</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:HttpVersion">HttpVersion</a></li><li class="src short"><a href="#v:rqCookies">rqCookies</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; [<a href="Snap-Types.html#t:Cookie">Cookie</a>]</li><li class="src short"><a href="#v:rqPathInfo">rqPathInfo</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqContextPath">rqContextPath</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqURI">rqURI</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqQueryString">rqQueryString</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:rqParams">rqParams</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Params">Params</a></li><li class="src short"><a href="#v:rqParam">rqParam</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</li><li class="src short"><a href="#v:getParam">getParam</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li class="src short"><a href="#v:getParams">getParams</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Params">Params</a></li><li class="src short"><a href="#v:rqModifyParams">rqModifyParams</a> :: (<a href="Snap-Types.html#t:Params">Params</a> -&gt; <a href="Snap-Types.html#t:Params">Params</a>) -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a></li><li class="src short"><a href="#v:rqSetParam">rqSetParam</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>] -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a></li><li class="src short"><a href="#v:emptyResponse">emptyResponse</a> :: <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:setResponseCode">setResponseCode</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:setResponseStatus">setResponseStatus</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:rspStatus">rspStatus</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:rspStatusReason">rspStatusReason</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:setContentType">setContentType</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:addCookie">addCookie</a> :: <a href="Snap-Types.html#t:Cookie">Cookie</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:addResponseCookie">addResponseCookie</a> :: <a href="Snap-Types.html#t:Cookie">Cookie</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:getResponseCookie">getResponseCookie</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Snap-Types.html#t:Cookie">Cookie</a></li><li class="src short"><a href="#v:getResponseCookies">getResponseCookies</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; [<a href="Snap-Types.html#t:Cookie">Cookie</a>]</li><li class="src short"><a href="#v:deleteResponseCookie">deleteResponseCookie</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:modifyResponseCookie">modifyResponseCookie</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; (<a href="Snap-Types.html#t:Cookie">Cookie</a> -&gt; <a href="Snap-Types.html#t:Cookie">Cookie</a>) -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:getCookie">getCookie</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Snap-Types.html#t:Cookie">Cookie</a>)</li><li class="src short"><a href="#v:readCookie">readCookie</a> :: (<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="Snap-Util-Readable.html#t:Readable">Readable</a> a) =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a</li><li class="src short"><a href="#v:setContentLength">setContentLength</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:clearContentLength">clearContentLength</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:redirect">redirect</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a</li><li class="src short"><a href="#v:redirect-39-">redirect'</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m a</li><li class="src short"><a href="#v:setResponseBody">setResponseBody</a> :: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:modifyResponseBody">modifyResponseBody</a> :: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a></li><li class="src short"><a href="#v:addToOutput">addToOutput</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:writeBuilder">writeBuilder</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:writeBS">writeBS</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:writeLazyText">writeLazyText</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; Text -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:writeText">writeText</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; Text -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:writeLBS">writeLBS</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:sendFile">sendFile</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:sendFilePartial">sendFilePartial</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:setTimeout">setTimeout</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:getTimeoutAction">getTimeoutAction</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Enumerator">Enumerator</a> a m b = <a href="Snap-Iteratee.html#t:Step">Step</a> a m b -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> a m b</li><li class="src short"><span class="keyword">data</span>  <a href="#t:SomeEnumerator">SomeEnumerator</a>  = <a href="#v:SomeEnumerator">SomeEnumerator</a> (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</li><li class="src short"><a href="#v:formatHttpTime">formatHttpTime</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:parseHttpTime">parseHttpTime</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a></li><li class="src short"><a href="#v:urlEncode">urlEncode</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li class="src short"><a href="#v:urlDecode">urlDecode</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li></ul></div><div id="interface"><h1 id="g:1">The Snap Monad
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Snap" class="def">Snap</a> a <a href="src/Snap-Internal-Types.html#Snap" class="link">Source</a></p><div class="subs instances"><p id="control.i:Snap" class="caption collapser" onclick="toggleSection('i:Snap')">Instances</p><div id="section.i:Snap" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Monad">Monad</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable1">Typeable1</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus">MonadPlus</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:MonadCatchIO">MonadCatchIO</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative">Alternative</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">MonadIO <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runSnap" class="def">runSnap</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; (<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>) -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> (<a href="Snap-Types.html#t:Request">Request</a>, <a href="Snap-Types.html#t:Response">Response</a>)<a href="src/Snap-Internal-Types.html#runSnap" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action in the 'Iteratee IO' monad.
</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Monad">Monad</a> m, MonadIO m, <a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:MonadCatchIO">MonadCatchIO</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus">MonadPlus</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Functor">Functor</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative">Alternative</a> m) =&gt; <a name="t:MonadSnap" class="def">MonadSnap</a> m  <span class="keyword">where</span><a href="src/Snap-Internal-Types.html#MonadSnap" class="link">Source</a></p><div class="doc"><p><code><a href="Snap-Types.html#t:Snap">Snap</a></code> is the <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:Monad">Monad</a></code> that user web handlers run in. <code><a href="Snap-Types.html#t:Snap">Snap</a></code> gives you:
</p><ol><li> stateful access to fetch or modify an HTTP <code><a href="Snap-Types.html#t:Request">Request</a></code>
</li><li> stateful access to fetch or modify an HTTP <code><a href="Snap-Types.html#t:Response">Response</a></code>
</li><li> failure / <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative">Alternative</a></code> / <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#t:MonadPlus">MonadPlus</a></code> semantics: a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> handler can
   choose not to handle a given request, using <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:empty">empty</a></code> or its synonym <code><a href="Snap-Types.html#v:pass">pass</a></code>,
   and you can try alternative handlers with the <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--124--62-">&lt;|&gt;</a></code> operator:
</li></ol><pre> a :: Snap String
 a = pass

 b :: Snap String
 b = return &quot;foo&quot;

 c :: Snap String
 c = a &lt;|&gt; b             -- try running a, if it fails then try b
</pre><ol><li> convenience functions (<code><a href="Snap-Types.html#v:writeBS">writeBS</a></code>, <code><a href="Snap-Types.html#v:writeLBS">writeLBS</a></code>, <code><a href="Snap-Types.html#v:writeText">writeText</a></code>, <code><a href="Snap-Types.html#v:writeLazyText">writeLazyText</a></code>,
   <code><a href="Snap-Types.html#v:addToOutput">addToOutput</a></code>) for writing output to the <code><a href="Snap-Types.html#t:Response">Response</a></code>:
</li></ol><pre> a :: (forall a . Enumerator a) -&gt; Snap ()
 a someEnumerator = do
     writeBS &quot;I'm a strict bytestring&quot;
     writeLBS &quot;I'm a lazy bytestring&quot;
     addToOutput someEnumerator
</pre><ol><li> early termination: if you call <code><a href="Snap-Types.html#v:finishWith">finishWith</a></code>:
</li></ol><pre> a :: Snap ()
 a = do
   modifyResponse $ setResponseStatus 500 &quot;Internal Server Error&quot;
   writeBS &quot;500 error&quot;
   r &lt;- getResponse
   finishWith r
</pre><p>then any subsequent processing will be skipped and supplied <code><a href="Snap-Types.html#t:Response">Response</a></code>
   value will be returned from <code><a href="Snap-Types.html#v:runSnap">runSnap</a></code> as-is.
</p><ol><li> access to the <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a></code> monad through a <code>MonadIO</code> instance:
</li></ol><pre> a :: Snap ()
 a = liftIO fireTheMissiles
</pre><ol><li> the ability to set a timeout which will kill the handler thread after <code>N</code>
   seconds of inactivity:
</li></ol><pre> a :: Snap ()
 a = setTimeout 30
</pre><p>You may notice that most of the type signatures in this module contain a
<code>(MonadSnap m) =&gt; ...</code> typeclass constraint. <code><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a></code> is a typeclass which,
in essence, says &quot;you can get back to the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad from here&quot;. Using
<code><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a></code> you can extend the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad with additional functionality and
still have access to most of the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> functions without writing <code>lift</code>
everywhere. Instances are already provided for most of the common monad
transformers (<code>ReaderT</code>, <code>WriterT</code>, <code>StateT</code>, etc.).
</p><p><code><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a></code> is a type class, analogous to <code>MonadIO</code> for <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a></code>, that makes
 it easy to wrap <code><a href="Snap-Types.html#t:Snap">Snap</a></code> inside monad transformers.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:liftSnap" class="def">liftSnap</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; m a<a href="src/Snap-Internal-Types.html#liftSnap" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:MonadSnap" class="caption collapser" onclick="toggleSection('i:MonadSnap')">Instances</p><div id="section.i:MonadSnap" class="show"><table><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> <a href="Snap-Types.html#t:Snap">Snap</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (ListT m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (StateT s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, Error e) =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (ErrorT e m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (WriterT w m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (WriterT w m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (StateT s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (ReaderT r m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (ContT c m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (RWST r w s m)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html#t:Monoid">Monoid</a> w) =&gt; <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> (RWST r w s m)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:NoHandlerException" class="def">NoHandlerException</a>  <a href="src/Snap-Internal-Types.html#NoHandlerException" class="link">Source</a></p><div class="doc"><p>This exception is thrown if the handler you supply to <code><a href="Snap-Types.html#v:runSnap">runSnap</a></code> fails.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:NoHandlerException" class="def">NoHandlerException</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:NoHandlerException" class="caption collapser" onclick="toggleSection('i:NoHandlerException')">Instances</p><div id="section.i:NoHandlerException" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Snap-Types.html#t:NoHandlerException">NoHandlerException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Types.html#t:NoHandlerException">NoHandlerException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable">Typeable</a> <a href="Snap-Types.html#t:NoHandlerException">NoHandlerException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:Exception">Exception</a> <a href="Snap-Types.html#t:NoHandlerException">NoHandlerException</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:2">Functions for control flow and early termination
</h2><div class="top"><p class="src"><a name="v:bracketSnap" class="def">bracketSnap</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> b) -&gt; (a -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> c) -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> c<a href="src/Snap-Internal-Types.html#bracketSnap" class="link">Source</a></p><div class="doc"><p>This function brackets a Snap action in resource acquisition and
 release. This is provided because MonadCatchIO's <code><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#v:bracket">bracket</a></code> function
 doesn't work properly in the case of a short-circuit return from
 the action being bracketed.
</p><p>In order to prevent confusion regarding the effects of the
 aquisition and release actions on the Snap state, this function
 doesn't accept Snap actions for the acquire or release actions.
</p><p>This function will run the release action in all cases where the
 acquire action succeeded.  This includes the following behaviors
 from the bracketed Snap action.
</p><ol><li> Normal completion
</li><li> Short-circuit completion, either from calling <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:fail">fail</a></code> or <code><a href="Snap-Types.html#v:finishWith">finishWith</a></code>
</li><li> An exception being thrown.
</li></ol></div></div><div class="top"><p class="src"><a name="v:finishWith" class="def">finishWith</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; m a<a href="src/Snap-Internal-Types.html#finishWith" class="link">Source</a></p><div class="doc"><p>Short-circuits a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action early, storing the given
 <code><a href="Snap-Types.html#t:Response">Response</a></code> value in its state.
</p></div></div><div class="top"><p class="src"><a name="v:catchFinishWith" class="def">catchFinishWith</a> ::  <a href="Snap-Types.html#t:Snap">Snap</a> a -&gt; <a href="Snap-Types.html#t:Snap">Snap</a> (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Snap-Types.html#t:Response">Response</a> a)<a href="src/Snap-Internal-Types.html#catchFinishWith" class="link">Source</a></p><div class="doc"><p>Capture the flow of control in case a handler calls <code><a href="Snap-Types.html#v:finishWith">finishWith</a></code>.
</p><p><em>WARNING</em>: in the event of a call to <code><a href="Snap-Types.html#v:transformRequestBody">transformRequestBody</a></code> it is possible
 to violate HTTP protocol safety when using this function. If you call
 <code><a href="Snap-Types.html#v:catchFinishWith">catchFinishWith</a></code> it is suggested that you do not modify the body of the
 <code><a href="Snap-Types.html#t:Response">Response</a></code> which was passed to the <code><a href="Snap-Types.html#v:finishWith">finishWith</a></code> call.
</p></div></div><div class="top"><p class="src"><a name="v:pass" class="def">pass</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m a<a href="src/Snap-Internal-Types.html#pass" class="link">Source</a></p><div class="doc"><p>Fails out of a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action.  This is used to indicate
 that you choose not to handle the given request within the given
 handler.
</p></div></div><h2 id="g:3">Routing
</h2><div class="top"><p class="src"><a name="v:method" class="def">method</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Method">Method</a> -&gt; m a -&gt; m a<a href="src/Snap-Internal-Types.html#method" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only if the request's HTTP method matches
 the given method.
</p></div></div><div class="top"><p class="src"><a name="v:methods" class="def">methods</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [<a href="Snap-Types.html#t:Method">Method</a>] -&gt; m a -&gt; m a<a href="src/Snap-Internal-Types.html#methods" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only if the request's HTTP method matches
 one of the given methods.
</p></div></div><div class="top"><p class="src"><a name="v:path" class="def">path</a><a href="src/Snap-Internal-Types.html#path" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>path to match against
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>handler to run
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only for requests where <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> is
 exactly equal to the given string. If the path matches, locally sets
 <code><a href="Snap-Types.html#v:rqContextPath">rqContextPath</a></code> to the old value of <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code>, sets <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code>=&quot;&quot;,
 and runs the given handler.
</p></div></div><div class="top"><p class="src"><a name="v:pathArg" class="def">pathArg</a> :: (<a href="Snap-Util-Readable.html#t:Readable">Readable</a> a, <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m) =&gt; (a -&gt; m b) -&gt; m b<a href="src/Snap-Internal-Types.html#pathArg" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only when the first path component is
 successfully parsed as the argument to the supplied handler function.
</p></div></div><div class="top"><p class="src"><a name="v:dir" class="def">dir</a><a href="src/Snap-Internal-Types.html#dir" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>path component to match
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc"><p>handler to run
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only when the <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> of the request
 starts with the given path. For example,
</p><pre> dir &quot;foo&quot; handler
</pre><p>Will fail if <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> is not &quot;<code>/foo</code>&quot; or &quot;<code>/foo/...</code>&quot;, and will
 add <code>&quot;foo/&quot;</code> to the handler's local <code><a href="Snap-Types.html#v:rqContextPath">rqContextPath</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:ifTop" class="def">ifTop</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m a -&gt; m a<a href="src/Snap-Internal-Types.html#ifTop" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad action only when <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> is empty.
</p></div></div><div class="top"><p class="src"><a name="v:route" class="def">route</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [(<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>, m a)] -&gt; m a<a href="src/Snap-Internal-Routing.html#route" class="link">Source</a></p><div class="doc"><p>A web handler which, given a mapping from URL entry points to web
 handlers, efficiently routes requests to the correct handler.
</p><p>The URL entry points are given as relative paths, for example:
</p><pre> route [ (&quot;foo/bar/quux&quot;, fooBarQuux) ]
</pre><p>If the URI of the incoming request is
</p><pre> /foo/bar/quux
</pre><p>or
</p><pre> /foo/bar/quux/...anything...
</pre><p>then the request will be routed to &quot;<code>fooBarQuux</code>&quot;, with <code><a href="Snap-Types.html#v:rqContextPath">rqContextPath</a></code>
 set to &quot;<code>/foo/bar/quux/</code>&quot; and <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> set to
 &quot;<code>...anything...</code>&quot;.
</p><p>A path component within an URL entry point beginning with a colon (&quot;<code>:</code>&quot;)
 is treated as a <em>variable capture</em>; the corresponding path component within
 the request URI will be entered into the <code><a href="Snap-Types.html#v:rqParams">rqParams</a></code> parameters mapping with
 the given name. For instance, if the routes were:
</p><pre> route [ (&quot;foo/:bar/baz&quot;, fooBazHandler) ]
</pre><p>Then a request for &quot;<code>/foo/saskatchewan/baz</code>&quot; would be routed to
 <code>fooBazHandler</code> with a mapping for:
</p><pre> &quot;bar&quot; =&gt; &quot;saskatchewan&quot;
</pre><p>in its parameters table.
</p><p>Longer paths are matched first, and specific routes are matched before
 captures. That is, if given routes:
</p><pre> [ (&quot;a&quot;, h1), (&quot;a/b&quot;, h2), (&quot;a/:x&quot;, h3) ]
</pre><p>a request for &quot;<code>/a/b</code>&quot; will go to <code>h2</code>, &quot;<code>/a/s</code>&quot; for any <em>s</em> will
 go to <code>h3</code>, and &quot;<code>/a</code>&quot; will go to <code>h1</code>.
</p><p>The following example matches &quot;<code>/article</code>&quot; to an article index,
 &quot;<code>/login</code>&quot; to a login, and &quot;<code>/article/...</code>&quot; to an article renderer.
</p><pre> route [ (&quot;article&quot;,     renderIndex)
       , (&quot;article/:id&quot;, renderArticle)
       , (&quot;login&quot;,       method POST doLogin) ]
</pre></div></div><div class="top"><p class="src"><a name="v:routeLocal" class="def">routeLocal</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; [(<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>, m a)] -&gt; m a<a href="src/Snap-Internal-Routing.html#routeLocal" class="link">Source</a></p><div class="doc"><p>The <code><a href="Snap-Types.html#v:routeLocal">routeLocal</a></code> function is the same as <code>route'</code>, except it doesn't
 change the request's context path. This is useful if you want to route to a
 particular handler but you want that handler to receive the <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> as
 it is.
</p></div></div><h2 id="g:4">Access to state
</h2><div class="top"><p class="src"><a name="v:getRequest" class="def">getRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Request">Request</a><a href="src/Snap-Internal-Types.html#getRequest" class="link">Source</a></p><div class="doc"><p>Grabs the <code><a href="Snap-Types.html#t:Request">Request</a></code> object out of the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:getResponse" class="def">getResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Types.html#getResponse" class="link">Source</a></p><div class="doc"><p>Grabs the <code><a href="Snap-Types.html#t:Response">Response</a></code> object out of the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:putRequest" class="def">putRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#putRequest" class="link">Source</a></p><div class="doc"><p>Puts a new <code><a href="Snap-Types.html#t:Request">Request</a></code> object into the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:putResponse" class="def">putResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#putResponse" class="link">Source</a></p><div class="doc"><p>Puts a new <code><a href="Snap-Types.html#t:Response">Response</a></code> object into the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:modifyRequest" class="def">modifyRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#modifyRequest" class="link">Source</a></p><div class="doc"><p>Modifies the <code><a href="Snap-Types.html#t:Request">Request</a></code> object stored in a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:modifyResponse" class="def">modifyResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#modifyResponse" class="link">Source</a></p><div class="doc"><p>Modifes the <code><a href="Snap-Types.html#t:Response">Response</a></code> object stored in a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:localRequest" class="def">localRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a>) -&gt; m a -&gt; m a<a href="src/Snap-Internal-Types.html#localRequest" class="link">Source</a></p><div class="doc"><p>Runs a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> action with a locally-modified <code><a href="Snap-Types.html#t:Request">Request</a></code> state
 object. The <code><a href="Snap-Types.html#t:Request">Request</a></code> object in the Snap monad state after the call
 to localRequest will be unchanged.
</p></div></div><div class="top"><p class="src"><a name="v:withRequest" class="def">withRequest</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Request">Request</a> -&gt; m a) -&gt; m a<a href="src/Snap-Internal-Types.html#withRequest" class="link">Source</a></p><div class="doc"><p>Fetches the <code><a href="Snap-Types.html#t:Request">Request</a></code> from state and hands it to the given action.
</p></div></div><div class="top"><p class="src"><a name="v:withResponse" class="def">withResponse</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; (<a href="Snap-Types.html#t:Response">Response</a> -&gt; m a) -&gt; m a<a href="src/Snap-Internal-Types.html#withResponse" class="link">Source</a></p><div class="doc"><p>Fetches the <code><a href="Snap-Types.html#t:Response">Response</a></code> from state and hands it to the given action.
</p></div></div><h2 id="g:5">Logging
</h2><div class="top"><p class="src"><a name="v:logError" class="def">logError</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#logError" class="link">Source</a></p><div class="doc"><p>Log an error message in the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad
</p></div></div><h2 id="g:6">Grabbing/transforming request bodies
</h2><div class="top"><p class="src"><a name="v:runRequestBody" class="def">runRequestBody</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; m a<a href="src/Snap-Internal-Types.html#runRequestBody" class="link">Source</a></p><div class="doc"><p>Sends the request body through an iteratee (data consumer) and
 returns the result.
</p></div></div><div class="top"><p class="src"><a name="v:getRequestBody" class="def">getRequestBody</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Types.html#getRequestBody" class="link">Source</a></p><div class="doc"><p>Returns the request body as a bytestring.
</p></div></div><div class="top"><p class="src"><a name="v:transformRequestBody" class="def">transformRequestBody</a><a href="src/Snap-Internal-Types.html#transformRequestBody" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</td><td class="doc"><p>the output <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code> is passed to this
 <code><a href="Snap-Types.html#t:Enumerator">Enumerator</a></code>, and then the resulting <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code> is
 fed the request body stream. Your <code><a href="Snap-Types.html#t:Enumerator">Enumerator</a></code> is
 responsible for transforming the input.
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Snap">Snap</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Normally Snap is careful to ensure that the request body is fully
 consumed after your web handler runs, but before the <code><a href="Snap-Types.html#t:Response">Response</a></code> enumerator
 is streamed out the socket. If you want to transform the request body into
 some output in O(1) space, you should use this function.
</p><p>Note that upon calling this function, response processing finishes early as
 if you called <code><a href="Snap-Types.html#v:finishWith">finishWith</a></code>. Make sure you set any content types, headers,
 cookies, etc. before you call this function.
</p></div></div><h1 id="g:7">HTTP Datatypes and Functions
</h1><div class="doc"><p>HTTP-related datatypes: <code><a href="Snap-Types.html#t:Request">Request</a></code>, <code><a href="Snap-Types.html#t:Response">Response</a></code>, <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code>, etc.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Request" class="def">Request</a>  <a href="src/Snap-Internal-Http-Types.html#Request" class="link">Source</a></p><div class="doc"><p>Contains all of the information about an incoming HTTP request.
</p></div><div class="subs instances"><p id="control.i:Request" class="caption collapser" onclick="toggleSection('i:Request')">Instances</p><div id="section.i:Request" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Response" class="def">Response</a>  <a href="src/Snap-Internal-Http-Types.html#Response" class="link">Source</a></p><div class="doc"><p>Represents an HTTP response.
</p></div><div class="subs instances"><p id="control.i:Response" class="caption collapser" onclick="toggleSection('i:Response')">Instances</p><div id="section.i:Response" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Headers" class="def">Headers</a> = <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t:Map">Map</a> (<a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>) [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]<a href="src/Snap-Internal-Http-Types.html#Headers" class="link">Source</a></p><div class="doc"><p>A type alias for a case-insensitive key-value mapping.
</p></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:HasHeaders" class="def">HasHeaders</a> a  <span class="keyword">where</span><a href="src/Snap-Internal-Http-Types.html#HasHeaders" class="link">Source</a></p><div class="doc"><p>A typeclass for datatypes which contain HTTP headers.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:updateHeaders" class="def">updateHeaders</a> :: (<a href="Snap-Types.html#t:Headers">Headers</a> -&gt; <a href="Snap-Types.html#t:Headers">Headers</a>) -&gt; a -&gt; a<a href="src/Snap-Internal-Http-Types.html#updateHeaders" class="link">Source</a></p><div class="doc"><p>Modify the datatype's headers.
</p></div><p class="src"><a name="v:headers" class="def">headers</a> :: a -&gt; <a href="Snap-Types.html#t:Headers">Headers</a><a href="src/Snap-Internal-Http-Types.html#headers" class="link">Source</a></p><div class="doc"><p>Retrieve the headers from a datatype that has headers.
</p></div></div><div class="subs instances"><p id="control.i:HasHeaders" class="caption collapser" onclick="toggleSection('i:HasHeaders')">Instances</p><div id="section.i:HasHeaders" class="show"><table><tr><td class="src"><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> <a href="Snap-Types.html#t:Headers">Headers</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Params" class="def">Params</a> = <a href="http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html#t:Map">Map</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]<a href="src/Snap-Internal-Http-Types.html#Params" class="link">Source</a></p><div class="doc"><p>A type alias for the HTTP parameters mapping. Each parameter
 key maps to a list of ByteString values; if a parameter is specified
 multiple times (e.g.: &quot;<code>GET /foo?param=bar1&amp;param=bar2</code>&quot;), looking up
 &quot;<code>param</code>&quot; in the mapping will give you <code>[&quot;bar1&quot;, &quot;bar2&quot;]</code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Method" class="def">Method</a>  <a href="src/Snap-Internal-Http-Types.html#Method" class="link">Source</a></p><div class="doc"><p>Enumerates the HTTP method values (see
 <a href="http://tools.ietf.org/html/rfc2068.html#section-5.1.1">http://tools.ietf.org/html/rfc2068.html#section-5.1.1</a>).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:GET" class="def">GET</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:HEAD" class="def">HEAD</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:POST" class="def">POST</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:PUT" class="def">PUT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:DELETE" class="def">DELETE</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:TRACE" class="def">TRACE</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:OPTIONS" class="def">OPTIONS</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:CONNECT" class="def">CONNECT</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Method" class="caption collapser" onclick="toggleSection('i:Method')">Instances</p><div id="section.i:Method" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Snap-Types.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Snap-Types.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#t:Read">Read</a> <a href="Snap-Types.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Types.html#t:Method">Method</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Cookie" class="def">Cookie</a>  <a href="src/Snap-Internal-Http-Types.html#Cookie" class="link">Source</a></p><div class="doc"><p>A datatype representing an HTTP cookie.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Cookie" class="def">Cookie</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:cookieName" class="def">cookieName</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></dt><dd class="doc"><p>The name of the cookie.
</p></dd><dt class="src"><a name="v:cookieValue" class="def">cookieValue</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></dt><dd class="doc"><p>The cookie's string value.
</p></dd><dt class="src"><a name="v:cookieExpires" class="def">cookieExpires</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime">UTCTime</a>)</dt><dd class="doc"><p>The cookie's expiration value, if it has one.
</p></dd><dt class="src"><a name="v:cookieDomain" class="def">cookieDomain</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</dt><dd class="doc"><p>The cookie's &quot;domain&quot; value, if it has one.
</p></dd><dt class="src"><a name="v:cookiePath" class="def">cookiePath</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</dt><dd class="doc"><p>The cookie path.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Cookie" class="caption collapser" onclick="toggleSection('i:Cookie')">Instances</p><div id="section.i:Cookie" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Snap-Types.html#t:Cookie">Cookie</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Types.html#t:Cookie">Cookie</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:HttpVersion" class="def">HttpVersion</a> = (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a>)<a href="src/Snap-Internal-Http-Types.html#HttpVersion" class="link">Source</a></p></div><h2 id="g:8">Headers
</h2><div class="top"><p class="src"><a name="v:addHeader" class="def">addHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a<a href="src/Snap-Internal-Http-Types.html#addHeader" class="link">Source</a></p><div class="doc"><p>Adds a header key-value-pair to the <code><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a></code> datatype. If a header
 with the same name already exists, the new value is appended to the headers
 list.
</p></div></div><div class="top"><p class="src"><a name="v:setHeader" class="def">setHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a<a href="src/Snap-Internal-Http-Types.html#setHeader" class="link">Source</a></p><div class="doc"><p>Sets a header key-value-pair in a <code><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a></code> datatype. If a header with
 the same name already exists, it is overwritten with the new value.
</p></div></div><div class="top"><p class="src"><a name="v:getHeader" class="def">getHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#getHeader" class="link">Source</a></p><div class="doc"><p>Gets a header value out of a <code><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a></code> datatype. If many headers came
 in with the same name, they will be catenated together.
</p></div></div><div class="top"><p class="src"><a name="v:deleteHeader" class="def">deleteHeader</a> :: <a href="Snap-Types.html#t:HasHeaders">HasHeaders</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; a -&gt; a<a href="src/Snap-Internal-Http-Types.html#deleteHeader" class="link">Source</a></p><div class="doc"><p>Clears a header value from a <code><a href="Snap-Types.html#t:HasHeaders">HasHeaders</a></code> datatype.
</p></div></div><div class="top"><p class="src"><a name="v:ipHeaderFilter" class="def">ipHeaderFilter</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#ipHeaderFilter" class="link">Source</a></p><div class="doc"><p>Modifies the <code><a href="Snap-Types.html#t:Request">Request</a></code> in the state to set the <code><a href="Snap-Types.html#v:rqRemoteAddr">rqRemoteAddr</a></code>
 field to the value in the X-Forwarded-For header. If the header is
 not present, this action has no effect.
</p><p>This action should be used only when working behind a reverse http
 proxy that sets the X-Forwarded-For header. This is the only way to
 ensure the value in the X-Forwarded-For header can be trusted.
</p><p>This is provided as a filter so actions that require the remote
 address can get it in a uniform manner. It has specifically limited
 functionality to ensure that its transformation can be trusted,
 when used correctly.
</p></div></div><div class="top"><p class="src"><a name="v:ipHeaderFilter-39-" class="def">ipHeaderFilter'</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/case-insensitive/latest/doc/html/Data-CaseInsensitive.html#t:CI">CI</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#ipHeaderFilter%27" class="link">Source</a></p><div class="doc"><p>Modifies the <code><a href="Snap-Types.html#t:Request">Request</a></code> in the state to set the <code><a href="Snap-Types.html#v:rqRemoteAddr">rqRemoteAddr</a></code>
 field to the value from the header specified.  If the header
 specified is not present, this action has no effect.
</p><p>This action should be used only when working behind a reverse http
 proxy that sets the header being looked at. This is the only way to
 ensure the value in the header can be trusted.
</p><p>This is provided as a filter so actions that require the remote
 address can get it in a uniform manner. It has specifically limited
 functionality to ensure that its transformation can be trusted,
 when used correctly.
</p></div></div><h2 id="g:9">Requests
</h2><div class="top"><p class="src"><a name="v:rqServerName" class="def">rqServerName</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqServerName" class="link">Source</a></p><div class="doc"><p>The server name of the request, as it came in from the request's
 <code>Host:</code> header.
</p></div></div><div class="top"><p class="src"><a name="v:rqServerPort" class="def">rqServerPort</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Internal-Http-Types.html#rqServerPort" class="link">Source</a></p><div class="doc"><p>Returns the port number the HTTP server is listening on.
</p></div></div><div class="top"><p class="src"><a name="v:rqRemoteAddr" class="def">rqRemoteAddr</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqRemoteAddr" class="link">Source</a></p><div class="doc"><p>The remote IP address.
</p></div></div><div class="top"><p class="src"><a name="v:rqRemotePort" class="def">rqRemotePort</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Internal-Http-Types.html#rqRemotePort" class="link">Source</a></p><div class="doc"><p>The remote TCP port number.
</p></div></div><div class="top"><p class="src"><a name="v:rqLocalAddr" class="def">rqLocalAddr</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqLocalAddr" class="link">Source</a></p><div class="doc"><p>The local IP address for this request.
</p></div></div><div class="top"><p class="src"><a name="v:rqLocalHostname" class="def">rqLocalHostname</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqLocalHostname" class="link">Source</a></p><div class="doc"><p>Returns the HTTP server's idea of its local hostname.
</p></div></div><div class="top"><p class="src"><a name="v:rqIsSecure" class="def">rqIsSecure</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Snap-Internal-Http-Types.html#rqIsSecure" class="link">Source</a></p><div class="doc"><p>Returns <code>True</code> if this is an <code>HTTPS</code> session.
</p></div></div><div class="top"><p class="src"><a name="v:rqContentLength" class="def">rqContentLength</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Internal-Http-Types.html#rqContentLength" class="link">Source</a></p><div class="doc"><p>Returns the <code>Content-Length</code> of the HTTP request body.
</p></div></div><div class="top"><p class="src"><a name="v:rqMethod" class="def">rqMethod</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Method">Method</a><a href="src/Snap-Internal-Http-Types.html#rqMethod" class="link">Source</a></p><div class="doc"><p>Returns the HTTP request method.
</p></div></div><div class="top"><p class="src"><a name="v:rqVersion" class="def">rqVersion</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:HttpVersion">HttpVersion</a><a href="src/Snap-Internal-Http-Types.html#rqVersion" class="link">Source</a></p><div class="doc"><p>Returns the HTTP version used by the client.
</p></div></div><div class="top"><p class="src"><a name="v:rqCookies" class="def">rqCookies</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; [<a href="Snap-Types.html#t:Cookie">Cookie</a>]<a href="src/Snap-Internal-Http-Types.html#rqCookies" class="link">Source</a></p><div class="doc"><p>Returns a list of the cookies that came in from the HTTP request
 headers.
</p></div></div><div class="top"><p class="src"><a name="v:rqPathInfo" class="def">rqPathInfo</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqPathInfo" class="link">Source</a></p><div class="doc"><p>Handlers can (<em>will be; --ed</em>) be hung on a <code>URI</code> &quot;entry point&quot;;
 this is called the &quot;context path&quot;. If a handler is hung on the
 context path <code>&quot;/foo/&quot;</code>, and you request <code>&quot;/foo/bar&quot;</code>, the
 value of <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> will be <code>&quot;bar&quot;</code>.
</p></div></div><div class="top"><p class="src"><a name="v:rqContextPath" class="def">rqContextPath</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqContextPath" class="link">Source</a></p><div class="doc"><p>The &quot;context path&quot; of the request; catenating <code><a href="Snap-Types.html#v:rqContextPath">rqContextPath</a></code>, and
 <code><a href="Snap-Types.html#v:rqPathInfo">rqPathInfo</a></code> should get you back to the original <code><a href="Snap-Types.html#v:rqURI">rqURI</a></code> (ignoring
 query strings). The <code><a href="Snap-Types.html#v:rqContextPath">rqContextPath</a></code> always begins and ends with a
 slash (<code>&quot;/&quot;</code>) character, and represents the path (relative to your
 component/snaplet) you took to get to your handler.
</p></div></div><div class="top"><p class="src"><a name="v:rqURI" class="def">rqURI</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqURI" class="link">Source</a></p><div class="doc"><p>Returns the <code>URI</code> requested by the client.
</p></div></div><div class="top"><p class="src"><a name="v:rqQueryString" class="def">rqQueryString</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rqQueryString" class="link">Source</a></p><div class="doc"><p>Returns the HTTP query string for this <code><a href="Snap-Types.html#t:Request">Request</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:rqParams" class="def">rqParams</a> :: <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Params">Params</a><a href="src/Snap-Internal-Http-Types.html#rqParams" class="link">Source</a></p><div class="doc"><p>Returns the <code><a href="Snap-Types.html#t:Params">Params</a></code> mapping for this <code><a href="Snap-Types.html#t:Request">Request</a></code>. &quot;Parameters&quot; are
 automatically decoded from the query string and <code>POST</code> body and
 entered into this mapping.
</p></div></div><div class="top"><p class="src"><a name="v:rqParam" class="def">rqParam</a><a href="src/Snap-Internal-Http-Types.html#rqParam" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>parameter name to look up
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc"><p>HTTP request
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Looks up the value(s) for the given named parameter. Parameters initially
 come from the request's query string and any decoded POST body (if the
 request's <code>Content-Type</code> is <code>application/x-www-form-urlencoded</code>).
 Parameter values can be modified within handlers using <a href="rqModifyParams.html">rqModifyParams</a>.
</p></div></div><div class="top"><p class="src"><a name="v:getParam" class="def">getParam</a><a href="src/Snap-Internal-Types.html#getParam" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>parameter name to look up
</p></td></tr><tr><td class="src">-&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>See <code><a href="Snap-Types.html#v:rqParam">rqParam</a></code>. Looks up a value for the given named parameter in the
 <code><a href="Snap-Types.html#t:Request">Request</a></code>. If more than one value was entered for the given parameter name,
 <code><a href="Snap-Types.html#v:getParam">getParam</a></code> gloms the values together with:
</p><pre>    <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:intercalate">intercalate</a></code> &quot; &quot;</pre></div></div><div class="top"><p class="src"><a name="v:getParams" class="def">getParams</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m <a href="Snap-Types.html#t:Params">Params</a><a href="src/Snap-Internal-Types.html#getParams" class="link">Source</a></p><div class="doc"><p>See <code><a href="Snap-Types.html#v:rqParams">rqParams</a></code>. Convenience function to return <code><a href="Snap-Types.html#t:Params">Params</a></code> from the
 <code><a href="Snap-Types.html#t:Request">Request</a></code> inside of a <code><a href="Snap-Types.html#t:MonadSnap">MonadSnap</a></code> instance.
</p></div></div><div class="top"><p class="src"><a name="v:rqModifyParams" class="def">rqModifyParams</a> :: (<a href="Snap-Types.html#t:Params">Params</a> -&gt; <a href="Snap-Types.html#t:Params">Params</a>) -&gt; <a href="Snap-Types.html#t:Request">Request</a> -&gt; <a href="Snap-Types.html#t:Request">Request</a><a href="src/Snap-Internal-Http-Types.html#rqModifyParams" class="link">Source</a></p><div class="doc"><p>Modifies the parameters mapping (which is a <code>Map ByteString ByteString</code>)
 in a <code><a href="Snap-Types.html#t:Request">Request</a></code> using the given function.
</p></div></div><div class="top"><p class="src"><a name="v:rqSetParam" class="def">rqSetParam</a><a href="src/Snap-Internal-Http-Types.html#rqSetParam" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>parameter name
</p></td></tr><tr><td class="src">-&gt; [<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>]</td><td class="doc"><p>parameter values
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc"><p>request
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Request">Request</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Writes a key-value pair to the parameters mapping within the given
 request.
</p></div></div><h2 id="g:10">Responses
</h2><div class="top"><p class="src"><a name="v:emptyResponse" class="def">emptyResponse</a> :: <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Http-Types.html#emptyResponse" class="link">Source</a></p><div class="doc"><p>An empty <code><a href="Snap-Types.html#t:Response">Response</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:setResponseCode" class="def">setResponseCode</a><a href="src/Snap-Internal-Http-Types.html#setResponseCode" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>HTTP response integer code
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>Response to be modified
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Sets the HTTP response code.
</p></div></div><div class="top"><p class="src"><a name="v:setResponseStatus" class="def">setResponseStatus</a><a href="src/Snap-Internal-Http-Types.html#setResponseStatus" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>HTTP response integer code
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>HTTP response explanation
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>Response to be modified
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Sets the HTTP response status. Note: normally you would use
 <code><a href="Snap-Types.html#v:setResponseCode">setResponseCode</a></code> unless you needed a custom response explanation.
</p></div></div><div class="top"><p class="src"><a name="v:rspStatus" class="def">rspStatus</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Internal-Http-Types.html#rspStatus" class="link">Source</a></p><div class="doc"><p>Returns the HTTP status code.
</p></div></div><div class="top"><p class="src"><a name="v:rspStatusReason" class="def">rspStatusReason</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#rspStatusReason" class="link">Source</a></p><div class="doc"><p>Returns the HTTP status explanation string.
</p></div></div><div class="top"><p class="src"><a name="v:setContentType" class="def">setContentType</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Http-Types.html#setContentType" class="link">Source</a></p><div class="doc"><p>Sets the <code>Content-Type</code> in the <code><a href="Snap-Types.html#t:Response">Response</a></code> headers.
</p></div></div><div class="top"><p class="src"><a name="v:addCookie" class="def">addCookie</a><a href="src/Snap-Internal-Http-Types.html#addCookie" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:Cookie">Cookie</a></td><td class="doc"><p>cookie value
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to modify
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>addCookie has been deprecated and will be removed in 0.5. Please use
 <code><a href="Snap-Types.html#v:addResponseCookie">addResponseCookie</a></code> instead.
</p></div></div><div class="top"><p class="src"><a name="v:addResponseCookie" class="def">addResponseCookie</a><a href="src/Snap-Internal-Http-Types.html#addResponseCookie" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:Cookie">Cookie</a></td><td class="doc"><p>cookie value
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to modify
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Adds an HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> to <code><a href="Snap-Types.html#t:Response">Response</a></code> headers.
</p></div></div><div class="top"><p class="src"><a name="v:getResponseCookie" class="def">getResponseCookie</a><a href="src/Snap-Internal-Http-Types.html#getResponseCookie" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>cookie name
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to query
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Snap-Types.html#t:Cookie">Cookie</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Gets an HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> with the given name from <code><a href="Snap-Types.html#t:Response">Response</a></code> headers.
</p></div></div><div class="top"><p class="src"><a name="v:getResponseCookies" class="def">getResponseCookies</a><a href="src/Snap-Internal-Http-Types.html#getResponseCookies" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to query
</p></td></tr><tr><td class="src">-&gt; [<a href="Snap-Types.html#t:Cookie">Cookie</a>]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Returns a list of <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code>s present in <code><a href="Snap-Types.html#t:Response">Response</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:deleteResponseCookie" class="def">deleteResponseCookie</a><a href="src/Snap-Internal-Http-Types.html#deleteResponseCookie" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>cookie name
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to modify
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Deletes an HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> from the <code><a href="Snap-Types.html#t:Response">Response</a></code> headers.
</p></div></div><div class="top"><p class="src"><a name="v:modifyResponseCookie" class="def">modifyResponseCookie</a><a href="src/Snap-Internal-Http-Types.html#modifyResponseCookie" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></td><td class="doc"><p>cookie name
</p></td></tr><tr><td class="src">-&gt; (<a href="Snap-Types.html#t:Cookie">Cookie</a> -&gt; <a href="Snap-Types.html#t:Cookie">Cookie</a>)</td><td class="doc"><p>modifier function
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to modify
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Modifies an HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> with given name in <code><a href="Snap-Types.html#t:Response">Response</a></code> headers.
 Nothing will happen if a matching <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> can not be found in <code><a href="Snap-Types.html#t:Response">Response</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:getCookie" class="def">getCookie</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Snap-Types.html#t:Cookie">Cookie</a>)<a href="src/Snap-Internal-Types.html#getCookie" class="link">Source</a></p><div class="doc"><p>Gets the HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> with the specified name.
</p></div></div><div class="top"><p class="src"><a name="v:readCookie" class="def">readCookie</a> :: (<a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m, <a href="Snap-Util-Readable.html#t:Readable">Readable</a> a) =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a<a href="src/Snap-Internal-Types.html#readCookie" class="link">Source</a></p><div class="doc"><p>Gets the HTTP <code><a href="Snap-Types.html#t:Cookie">Cookie</a></code> with the specified name and decodes it.  If the
 decoding fails, the handler calls pass.
</p></div></div><div class="top"><p class="src"><a name="v:setContentLength" class="def">setContentLength</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Http-Types.html#setContentLength" class="link">Source</a></p><div class="doc"><p>A note here: if you want to set the <code>Content-Length</code> for the response,
 Snap forces you to do it with this function rather than by setting it in
 the headers; the <code>Content-Length</code> in the headers will be ignored.
</p><p>The reason for this is that Snap needs to look up the value of
 <code>Content-Length</code> for each request, and looking the string value up in the
 headers and parsing the number out of the text will be too expensive.
</p><p>If you don't set a content length in your response, HTTP keep-alive will be
 disabled for HTTP/1.0 clients, forcing a <code>Connection: close</code>. For
 HTTP/1.1 clients, Snap will switch to the chunked transfer encoding if
 <code>Content-Length</code> is not specified.
</p></div></div><div class="top"><p class="src"><a name="v:clearContentLength" class="def">clearContentLength</a> :: <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Http-Types.html#clearContentLength" class="link">Source</a></p><div class="doc"><p>Removes any <code>Content-Length</code> set in the <code><a href="Snap-Types.html#t:Response">Response</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:redirect" class="def">redirect</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m a<a href="src/Snap-Internal-Types.html#redirect" class="link">Source</a></p><div class="doc"><p>Performs a redirect by setting the <code>Location</code> header to the given target
 URL/path and the status code to 302 in the <code><a href="Snap-Types.html#t:Response">Response</a></code> object stored in a
 <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad. Note that the target URL is not validated in any way.
 Consider using 'redirect\'' instead, which allows you to choose the correct
 status code.
</p></div></div><div class="top"><p class="src"><a name="v:redirect-39-" class="def">redirect'</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m a<a href="src/Snap-Internal-Types.html#redirect%27" class="link">Source</a></p><div class="doc"><p>Performs a redirect by setting the <code>Location</code> header to the given target
 URL/path and the status code (should be one of 301, 302, 303 or 307) in the
 <code><a href="Snap-Types.html#t:Response">Response</a></code> object stored in a <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad. Note that the target URL is not
 validated in any way.
</p></div></div><h3 id="g:11">Response I/O
</h3><div class="top"><p class="src"><a name="v:setResponseBody" class="def">setResponseBody</a><a href="src/Snap-Internal-Http-Types.html#setResponseBody" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</td><td class="doc"><p>new response body enumerator
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc"><p>response to modify
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Types.html#t:Response">Response</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Sets an HTTP response body to the given <code><a href="Snap-Types.html#t:Enumerator">Enumerator</a></code> value.
</p></div></div><div class="top"><p class="src"><a name="v:modifyResponseBody" class="def">modifyResponseBody</a> :: (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a -&gt; <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; <a href="Snap-Types.html#t:Response">Response</a> -&gt; <a href="Snap-Types.html#t:Response">Response</a><a href="src/Snap-Internal-Http-Types.html#modifyResponseBody" class="link">Source</a></p><div class="doc"><p>Modifies a response body.
</p></div></div><div class="top"><p class="src"><a name="v:addToOutput" class="def">addToOutput</a><a href="src/Snap-Internal-Types.html#addToOutput" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</td><td class="doc"><p>output to add
</p></td></tr><tr><td class="src">-&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Adds the output from the given enumerator to the <code><a href="Snap-Types.html#t:Response">Response</a></code>
 stored in the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p></div></div><div class="top"><p class="src"><a name="v:writeBuilder" class="def">writeBuilder</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#writeBuilder" class="link">Source</a></p><div class="doc"><p>Adds the given <code><a href="http://hackage.haskell.org/packages/archive/blaze-builder/latest/doc/html/Blaze-ByteString-Builder-Internal-Types.html#t:Builder">Builder</a></code> to the body of the <code><a href="Snap-Types.html#t:Response">Response</a></code> stored in the
 | <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p></div></div><div class="top"><p class="src"><a name="v:writeBS" class="def">writeBS</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#writeBS" class="link">Source</a></p><div class="doc"><p>Adds the given strict <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></code> to the body of the <code><a href="Snap-Types.html#t:Response">Response</a></code> stored
 in the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p><p>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></code>,
 the exception won't actually be raised within the Snap handler.
</p></div></div><div class="top"><p class="src"><a name="v:writeLazyText" class="def">writeLazyText</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; Text -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#writeLazyText" class="link">Source</a></p><div class="doc"><p>Adds the given lazy <code>Text</code> to the body of the <code><a href="Snap-Types.html#t:Response">Response</a></code> stored in the
 <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p><p>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></code>,
 the exception won't actually be raised within the Snap handler.
</p></div></div><div class="top"><p class="src"><a name="v:writeText" class="def">writeText</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; Text -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#writeText" class="link">Source</a></p><div class="doc"><p>Adds the given strict <code>Text</code> to the body of the <code><a href="Snap-Types.html#t:Response">Response</a></code> stored in
 the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p><p>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></code>,
 the exception won't actually be raised within the Snap handler.
</p></div></div><div class="top"><p class="src"><a name="v:writeLBS" class="def">writeLBS</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#writeLBS" class="link">Source</a></p><div class="doc"><p>Adds the given lazy <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy.html#t:ByteString">ByteString</a></code> to the body of the <code><a href="Snap-Types.html#t:Response">Response</a></code> stored
 in the <code><a href="Snap-Types.html#t:Snap">Snap</a></code> monad state.
</p><p>Warning: This function is intentionally non-strict. If any pure
 exceptions are raised by the expression creating the <code><a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></code>,
 the exception won't actually be raised within the Snap handler.
</p></div></div><div class="top"><p class="src"><a name="v:sendFile" class="def">sendFile</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#sendFile" class="link">Source</a></p><div class="doc"><p>Sets the output to be the contents of the specified file.
</p><p>Calling <code><a href="Snap-Types.html#v:sendFile">sendFile</a></code> will overwrite any output queued to be sent in the
 <code><a href="Snap-Types.html#t:Response">Response</a></code>. If the response body is not modified after the call to
 <code><a href="Snap-Types.html#v:sendFile">sendFile</a></code>, Snap will use the efficient <code>sendfile()</code> system call on
 platforms that support it.
</p><p>If the response body is modified (using <code><a href="Snap-Types.html#v:modifyResponseBody">modifyResponseBody</a></code>), the file
 will be read using <code>mmap()</code>.
</p></div></div><div class="top"><p class="src"><a name="v:sendFilePartial" class="def">sendFilePartial</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a>) -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#sendFilePartial" class="link">Source</a></p><div class="doc"><p>Sets the output to be the contents of the specified file, within the
 given (start,end) range.
</p><p>Calling <code><a href="Snap-Types.html#v:sendFilePartial">sendFilePartial</a></code> will overwrite any output queued to be sent in
 the <code><a href="Snap-Types.html#t:Response">Response</a></code>. If the response body is not modified after the call to
 <code><a href="Snap-Types.html#v:sendFilePartial">sendFilePartial</a></code>, Snap will use the efficient <code>sendfile()</code> system call on
 platforms that support it.
</p><p>If the response body is modified (using <code><a href="Snap-Types.html#v:modifyResponseBody">modifyResponseBody</a></code>), the file
 will be read using <code>mmap()</code>.
</p></div></div><h2 id="g:12">Timeouts
</h2><div class="top"><p class="src"><a name="v:setTimeout" class="def">setTimeout</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a><a href="src/Snap-Internal-Types.html#setTimeout" class="link">Source</a></p><div class="doc"><p>Causes the handler thread to be killed <code>n</code> seconds from now.
</p></div></div><div class="top"><p class="src"><a name="v:getTimeoutAction" class="def">getTimeoutAction</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; m (<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/ghc-prim/latest/doc/html/GHC-Unit.html#t:-40--41-">()</a>)<a href="src/Snap-Internal-Types.html#getTimeoutAction" class="link">Source</a></p><div class="doc"><p>Returns an <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a></code> action which you can use to reset the handling thread's
 timeout value.
</p></div></div><h1 id="g:13">Iteratee
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Enumerator" class="def">Enumerator</a> a m b = <a href="Snap-Iteratee.html#t:Step">Step</a> a m b -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> a m b</p><div class="doc"><p>While <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code>s consume data, enumerators generate it. Since
 <code><code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code></code> is an alias for <code>m (<code><a href="Snap-Iteratee.html#t:Step">Step</a></code> a m b)</code>, <code><a href="Snap-Types.html#t:Enumerator">Enumerator</a></code>s can
 be considered step transformers of type
 <code><code><a href="Snap-Iteratee.html#t:Step">Step</a></code> a m b -&gt; m (<code><a href="Snap-Iteratee.html#t:Step">Step</a></code> a m b)</code>.
</p><p><code><a href="Snap-Types.html#t:Enumerator">Enumerator</a></code>s typically read from an external source (parser, handle,
 random generator, etc). They feed chunks into an <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code> until the
 source runs out of data (triggering <code><a href="Snap-Iteratee.html#v:EOF">EOF</a></code>) or the iteratee finishes
 processing (<code><a href="Snap-Iteratee.html#v:Yield">Yield</a></code>s a value).
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:SomeEnumerator" class="def">SomeEnumerator</a>  <a href="src/Snap-Internal-Http-Types.html#SomeEnumerator" class="link">Source</a></p><div class="doc"><p>An existential wrapper for the 'Enumerator ByteString IO a' type
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:SomeEnumerator" class="def">SomeEnumerator</a> (<span class="keyword">forall</span> a.  <a href="Snap-Types.html#t:Enumerator">Enumerator</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><h1 id="g:14">HTTP utilities
</h1><div class="top"><p class="src"><a name="v:formatHttpTime" class="def">formatHttpTime</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#formatHttpTime" class="link">Source</a></p><div class="doc"><p>Converts a <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a></code> into an HTTP timestamp.
</p></div></div><div class="top"><p class="src"><a name="v:parseHttpTime" class="def">parseHttpTime</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a><a href="src/Snap-Internal-Http-Types.html#parseHttpTime" class="link">Source</a></p><div class="doc"><p>Converts an HTTP timestamp into a <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime">CTime</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:urlEncode" class="def">urlEncode</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#urlEncode" class="link">Source</a></p><div class="doc"><p>URL-escapes a string (see
 <a href="http://tools.ietf.org/html/rfc2396.html#section-2.4">http://tools.ietf.org/html/rfc2396.html#section-2.4</a>)
</p></div></div><div class="top"><p class="src"><a name="v:urlDecode" class="def">urlDecode</a> :: <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a><a href="src/Snap-Internal-Http-Types.html#urlDecode" class="link">Source</a></p><div class="doc"><p>Decodes an URL-escaped string (see
 <a href="http://tools.ietf.org/html/rfc2396.html#section-2.4">http://tools.ietf.org/html/rfc2396.html#section-2.4</a>)
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.9.2</p></div></body></html>