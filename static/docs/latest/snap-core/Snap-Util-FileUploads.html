<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Snap.Util.FileUploads</title><link href="haddock.css" rel="stylesheet" type="text/css" title="haddock" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Snap-Util-FileUploads.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Snap-Util-FileUploads.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">snap-core-0.5.1: Snap: A Haskell Web Framework (Core)</p></div><div id="content"><div id="module-header"><p class="caption">Snap.Util.FileUploads</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Functions
</a></li><li><a href="#g:2">Uploaded parts
</a><ul><li><a href="#g:3">Policy
</a><ul><li><a href="#g:4">General upload policy
</a></li><li><a href="#g:5">Per-file upload policy
</a></li></ul></li></ul></li><li><a href="#g:6">Exceptions
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains primitives and helper functions for handling
 requests with <code>Content-type: multipart/form-data</code>, i.e. HTML forms and file
 uploads.
</p><p>Typically most users will want to use <code><a href="Snap-Util-FileUploads.html#v:handleFileUploads">handleFileUploads</a></code>, which writes
 uploaded files to a temporary directory before sending them on to a handler
 specified by the user.
</p><p>Users who wish to handle their file uploads differently can use the
 lower-level streaming <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code> interface called <code><a href="Snap-Util-FileUploads.html#v:handleMultipart">handleMultipart</a></code>. That
 function takes uploaded files and streams them to an <code><a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a></code> consumer of
 the user's choosing.
</p><p>Using these functions requires making &quot;policy&quot; decisions which Snap can't
 really make for users, such as &quot;what's the largest PDF file a user is
 allowed to upload?&quot; and &quot;should we read form inputs into the parameters
 mapping?&quot;. Policy is specified on a &quot;global&quot; basis (using
 <code><a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></code>), and on a per-file basis (using <code><a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></code>, which
 allows you to reject or limit the size of certain uploaded
 <code>Content-type</code>s).
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:handleFileUploads">handleFileUploads</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; (<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a> -&gt; <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a>) -&gt; ([(<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a>)] -&gt; m a) -&gt; m a</li><li class="src short"><a href="#v:handleMultipart">handleMultipart</a> :: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m =&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; (<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a> -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a) -&gt; m [a]</li><li class="src short"><span class="keyword">data</span>  <a href="#t:PartInfo">PartInfo</a>  = <a href="#v:PartInfo">PartInfo</a> {<ul class="subs"><li><a href="#v:partFieldName">partFieldName</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li><li><a href="#v:partFileName">partFileName</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</li><li><a href="#v:partContentType">partContentType</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:UploadPolicy">UploadPolicy</a> </li><li class="src short"><a href="#v:defaultUploadPolicy">defaultUploadPolicy</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><a href="#v:doProcessFormInputs">doProcessFormInputs</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:setProcessFormInputs">setProcessFormInputs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><a href="#v:getMaximumFormInputSize">getMaximumFormInputSize</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:setMaximumFormInputSize">setMaximumFormInputSize</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><a href="#v:getMinimumUploadRate">getMinimumUploadRate</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double">Double</a></li><li class="src short"><a href="#v:setMinimumUploadRate">setMinimumUploadRate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><a href="#v:getMinimumUploadSeconds">getMinimumUploadSeconds</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:setMinimumUploadSeconds">setMinimumUploadSeconds</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><a href="#v:getUploadTimeout">getUploadTimeout</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:setUploadTimeout">setUploadTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:PartUploadPolicy">PartUploadPolicy</a> </li><li class="src short"><a href="#v:disallow">disallow</a> :: <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></li><li class="src short"><a href="#v:allowWithMaximumSize">allowWithMaximumSize</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:FileUploadException">FileUploadException</a> </li><li class="src short"><a href="#v:fileUploadExceptionReason">fileUploadExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a> -&gt; Text</li><li class="src short"><span class="keyword">data</span>  <a href="#t:BadPartException">BadPartException</a> </li><li class="src short"><a href="#v:badPartExceptionReason">badPartExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a> -&gt; Text</li><li class="src short"><span class="keyword">data</span>  <a href="#t:PolicyViolationException">PolicyViolationException</a> </li><li class="src short"><a href="#v:policyViolationExceptionReason">policyViolationExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a> -&gt; Text</li></ul></div><div id="interface"><h1 id="g:1">Functions
</h1><div class="top"><p class="src"><a name="v:handleFileUploads" class="def">handleFileUploads</a><a href="src/Snap-Util-FileUploads.html#handleFileUploads" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a></td><td class="doc"><p>temporary directory
</p></td></tr><tr><td class="src">-&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></td><td class="doc"><p>general upload policy
</p></td></tr><tr><td class="src">-&gt; (<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a> -&gt; <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a>)</td><td class="doc"><p>per-part upload policy
</p></td></tr><tr><td class="src">-&gt; ([(<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a>, <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a> <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:FilePath">FilePath</a>)] -&gt; m a)</td><td class="doc"><p>user handler (see function
 description)
</p></td></tr><tr><td class="src">-&gt; m a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Reads uploaded files into a temporary directory and calls a user handler
 to process them.
</p><p>Given a temporary directory, global and file-specific upload policies, and
 a user handler, this function consumes a request body uploaded with
 <code>Content-type: multipart/form-data</code>. Each file is read into the temporary
 directory, and then a list of the uploaded files is passed to the user
 handler. After the user handler runs (but before the <code><a href="Snap-Internal-Http-Types.html#t:Response">Response</a></code> body
 <code><a href="Snap-Iteratee.html#t:Enumerator">Enumerator</a></code> is streamed to the client), the files are deleted from disk;
 so if you want to retain or use the uploaded files in the generated
 response, you would need to move or otherwise process them.
</p><p>The argument passed to the user handler is a list of:
</p><pre> (PartInfo, Either PolicyViolationException FilePath)
</pre><p>The first half of this tuple is a <code><a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a></code>, which contains the
 information the client browser sent about the given upload part (like
 filename, content-type, etc). The second half of this tuple is an <code><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Either.html#t:Either">Either</a></code>
 stipulating that either:
</p><ol><li> the file was rejected on a policy basis because of the provided
    <code><a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></code> handler
</li><li> the file was accepted and exists at the given path.
</li></ol><p>If the request's <code>Content-type</code> was not &quot;<code>multipart/formdata</code>&quot;, this
 function skips processing using <code><a href="Snap-Types.html#v:pass">pass</a></code>.
</p><p>If the client's upload rate passes below the configured minimum (see
 <code><a href="Snap-Util-FileUploads.html#v:setMinimumUploadRate">setMinimumUploadRate</a></code> and <code><a href="Snap-Util-FileUploads.html#v:setMinimumUploadSeconds">setMinimumUploadSeconds</a></code>), this function throws
 a <code><a href="Snap-Iteratee.html#t:RateTooSlowException">RateTooSlowException</a></code>. This setting is there to protect the server
 against slowloris-style denial of service attacks.
</p><p>If the given <code><a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></code> stipulates that you wish form inputs to be
 placed in the <code><a href="Snap-Internal-Http-Types.html#v:rqParams">rqParams</a></code> parameter map (using <code><a href="Snap-Util-FileUploads.html#v:setProcessFormInputs">setProcessFormInputs</a></code>), and
 a form input exceeds the maximum allowable size, this function will throw a
 <code><a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></code>.
</p><p>If an uploaded part contains MIME headers longer than a fixed internal
 threshold (currently 32KB), this function will throw a <code><a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:handleMultipart" class="def">handleMultipart</a><a href="src/Snap-Util-FileUploads.html#handleMultipart" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Snap-Types.html#t:MonadSnap">MonadSnap</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></td><td class="doc"><p>global upload policy
</p></td></tr><tr><td class="src">-&gt; (<a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a> -&gt; <a href="Snap-Iteratee.html#t:Iteratee">Iteratee</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a> <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:IO">IO</a> a)</td><td class="doc"><p>part processor
</p></td></tr><tr><td class="src">-&gt; m [a]</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Given an upload policy and a function to consume uploaded &quot;parts&quot;,
 consume a request body uploaded with <code>Content-type: multipart/form-data</code>.
 Normally most users will want to use <code><a href="Snap-Util-FileUploads.html#v:handleFileUploads">handleFileUploads</a></code> (which writes
 uploaded files to a temporary directory and passes their names to a given
 handler) rather than this function; the lower-level <code><a href="Snap-Util-FileUploads.html#v:handleMultipart">handleMultipart</a></code>
 function should be used if you want to stream uploaded files to your own
 iteratee function.
</p><p>If the request's <code>Content-type</code> was not &quot;<code>multipart/formdata</code>&quot;, this
 function skips processing using <code><a href="Snap-Types.html#v:pass">pass</a></code>.
</p><p>If the client's upload rate passes below the configured minimum (see
 <code><a href="Snap-Util-FileUploads.html#v:setMinimumUploadRate">setMinimumUploadRate</a></code> and <code><a href="Snap-Util-FileUploads.html#v:setMinimumUploadSeconds">setMinimumUploadSeconds</a></code>), this function throws
 a <code><a href="Snap-Iteratee.html#t:RateTooSlowException">RateTooSlowException</a></code>. This setting is there to protect the server
 against slowloris-style denial of service attacks.
</p><p>If the given <code><a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></code> stipulates that you wish form inputs to be
 placed in the <code><a href="Snap-Internal-Http-Types.html#v:rqParams">rqParams</a></code> parameter map (using <code><a href="Snap-Util-FileUploads.html#v:setProcessFormInputs">setProcessFormInputs</a></code>), and
 a form input exceeds the maximum allowable size, this function will throw a
 <code><a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></code>.
</p><p>If an uploaded part contains MIME headers longer than a fixed internal
 threshold (currently 32KB), this function will throw a <code><a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></code>.
</p></div></div><h1 id="g:2">Uploaded parts
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:PartInfo" class="def">PartInfo</a>  <a href="src/Snap-Util-FileUploads.html#PartInfo" class="link">Source</a></p><div class="doc"><p><code><a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a></code> contains information about a &quot;part&quot; in a request uploaded
 with <code>Content-type: multipart/form-data</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:PartInfo" class="def">PartInfo</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:partFieldName" class="def">partFieldName</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:partFileName" class="def">partFileName</a> :: !(<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a>)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:partContentType" class="def">partContentType</a> :: !<a href="http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString">ByteString</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:PartInfo" class="caption collapser" onclick="toggleSection('i:PartInfo')">Instances</p><div id="section.i:PartInfo" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:PartInfo">PartInfo</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:3">Policy
</h2><h3 id="g:4">General upload policy
</h3><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:UploadPolicy" class="def">UploadPolicy</a>  <a href="src/Snap-Util-FileUploads.html#UploadPolicy" class="link">Source</a></p><div class="doc"><p><code><a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></code> controls overall policy decisions relating to
 <code>multipart/form-data</code> uploads, specifically:
</p><ul><li> whether to treat parts without filenames as form input (reading them into
   the <code><a href="Snap-Internal-Http-Types.html#v:rqParams">rqParams</a></code> map)
</li><li> because form input is read into memory, the maximum size of a form input
   read in this manner, and the maximum number of form inputs
</li><li> the minimum upload rate a client must maintain before we kill the
   connection; if very low-bitrate uploads were allowed then a Snap server
   would be vulnerable to a trivial denial-of-service using a
   &quot;slowloris&quot;-type attack
</li><li> the minimum number of seconds which must elapse before we start killing
   uploads for having too low an upload rate.
</li><li> the amount of time we should wait before timing out the connection
   whenever we receive input from the client.
</li></ul></div><div class="subs instances"><p id="control.i:UploadPolicy" class="caption collapser" onclick="toggleSection('i:UploadPolicy')">Instances</p><div id="section.i:UploadPolicy" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:defaultUploadPolicy" class="def">defaultUploadPolicy</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#defaultUploadPolicy" class="link">Source</a></p><div class="doc"><p>A reasonable set of defaults for upload policy. The default policy is:
</p><dl><dt><code>maximum form input size</code></dt><dd>                128kB
</dd><dt><code>maximum number of form inputs</code></dt><dd>          10
</dd><dt><code>minimum upload rate</code></dt><dd>                    1kB/s
</dd><dt><code>seconds before rate limiting kicks in</code></dt><dd>  10
</dd><dt><code>inactivity timeout</code></dt><dd>                     20 seconds
</dd></dl></div></div><div class="top"><p class="src"><a name="v:doProcessFormInputs" class="def">doProcessFormInputs</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Snap-Util-FileUploads.html#doProcessFormInputs" class="link">Source</a></p><div class="doc"><p>Does this upload policy stipulate that we want to treat parts without
 filenames as form input?
</p></div></div><div class="top"><p class="src"><a name="v:setProcessFormInputs" class="def">setProcessFormInputs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#setProcessFormInputs" class="link">Source</a></p><div class="doc"><p>Set the upload policy for treating parts without filenames as form input.
</p></div></div><div class="top"><p class="src"><a name="v:getMaximumFormInputSize" class="def">getMaximumFormInputSize</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Util-FileUploads.html#getMaximumFormInputSize" class="link">Source</a></p><div class="doc"><p>Get the maximum size of a form input which will be read into our
   <code><a href="Snap-Internal-Http-Types.html#v:rqParams">rqParams</a></code> map.
</p></div></div><div class="top"><p class="src"><a name="v:setMaximumFormInputSize" class="def">setMaximumFormInputSize</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#setMaximumFormInputSize" class="link">Source</a></p><div class="doc"><p>Set the maximum size of a form input which will be read into our
   <code><a href="Snap-Internal-Http-Types.html#v:rqParams">rqParams</a></code> map.
</p></div></div><div class="top"><p class="src"><a name="v:getMinimumUploadRate" class="def">getMinimumUploadRate</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double">Double</a><a href="src/Snap-Util-FileUploads.html#getMinimumUploadRate" class="link">Source</a></p><div class="doc"><p>Get the minimum rate (in <em>bytes\</em>second/) a client must maintain before
   we kill the connection.
</p></div></div><div class="top"><p class="src"><a name="v:setMinimumUploadRate" class="def">setMinimumUploadRate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#setMinimumUploadRate" class="link">Source</a></p><div class="doc"><p>Set the minimum rate (in <em>bytes\</em>second/) a client must maintain before
   we kill the connection.
</p></div></div><div class="top"><p class="src"><a name="v:getMinimumUploadSeconds" class="def">getMinimumUploadSeconds</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Util-FileUploads.html#getMinimumUploadSeconds" class="link">Source</a></p><div class="doc"><p>Get the amount of time which must elapse before we begin enforcing the
   upload rate minimum
</p></div></div><div class="top"><p class="src"><a name="v:setMinimumUploadSeconds" class="def">setMinimumUploadSeconds</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#setMinimumUploadSeconds" class="link">Source</a></p><div class="doc"><p>Set the amount of time which must elapse before we begin enforcing the
   upload rate minimum
</p></div></div><div class="top"><p class="src"><a name="v:getUploadTimeout" class="def">getUploadTimeout</a> :: <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Snap-Util-FileUploads.html#getUploadTimeout" class="link">Source</a></p><div class="doc"><p>Get the &quot;upload timeout&quot;. Whenever input is received from the client,
   the connection timeout is set this many seconds in the future.
</p></div></div><div class="top"><p class="src"><a name="v:setUploadTimeout" class="def">setUploadTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a> -&gt; <a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a><a href="src/Snap-Util-FileUploads.html#setUploadTimeout" class="link">Source</a></p><div class="doc"><p>Set the upload timeout.
</p></div></div><h3 id="g:5">Per-file upload policy
</h3><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:PartUploadPolicy" class="def">PartUploadPolicy</a>  <a href="src/Snap-Util-FileUploads.html#PartUploadPolicy" class="link">Source</a></p><div class="doc"><p>Upload policy can be set on an &quot;general&quot; basis (using <code><a href="Snap-Util-FileUploads.html#t:UploadPolicy">UploadPolicy</a></code>),
   but handlers can also make policy decisions on individual files/parts
   uploaded. For each part uploaded, handlers can decide:
</p><ul><li> whether to allow the file upload at all
</li><li> the maximum size of uploaded files, if allowed
</li></ul></div><div class="subs instances"><p id="control.i:PartUploadPolicy" class="caption collapser" onclick="toggleSection('i:PartUploadPolicy')">Instances</p><div id="section.i:PartUploadPolicy" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:disallow" class="def">disallow</a> :: <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a><a href="src/Snap-Util-FileUploads.html#disallow" class="link">Source</a></p><div class="doc"><p>Disallows the file to be uploaded.
</p></div></div><div class="top"><p class="src"><a name="v:allowWithMaximumSize" class="def">allowWithMaximumSize</a> :: <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Int.html#t:Int64">Int64</a> -&gt; <a href="Snap-Util-FileUploads.html#t:PartUploadPolicy">PartUploadPolicy</a><a href="src/Snap-Util-FileUploads.html#allowWithMaximumSize" class="link">Source</a></p><div class="doc"><p>Allows the file to be uploaded, with maximum size <em>n</em>.
</p></div></div><h1 id="g:6">Exceptions
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:FileUploadException" class="def">FileUploadException</a>  <a href="src/Snap-Util-FileUploads.html#FileUploadException" class="link">Source</a></p><div class="doc"><p>All of the exceptions defined in this package inherit from
 <code><a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a></code>, so if you write
</p><pre> foo `catch` \(e :: FileUploadException) -&gt; ...
</pre><p>you can catch a <code><a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></code>, a <code><a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></code>, etc.
</p></div><div class="subs instances"><p id="control.i:FileUploadException" class="caption collapser" onclick="toggleSection('i:FileUploadException')">Instances</p><div id="section.i:FileUploadException" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable">Typeable</a> <a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:Exception">Exception</a> <a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:fileUploadExceptionReason" class="def">fileUploadExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:FileUploadException">FileUploadException</a> -&gt; Text<a href="src/Snap-Util-FileUploads.html#fileUploadExceptionReason" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:BadPartException" class="def">BadPartException</a>  <a href="src/Snap-Util-FileUploads.html#BadPartException" class="link">Source</a></p><div class="subs instances"><p id="control.i:BadPartException" class="caption collapser" onclick="toggleSection('i:BadPartException')">Instances</p><div id="section.i:BadPartException" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable">Typeable</a> <a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:Exception">Exception</a> <a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:badPartExceptionReason" class="def">badPartExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:BadPartException">BadPartException</a> -&gt; Text<a href="src/Snap-Util-FileUploads.html#badPartExceptionReason" class="link">Source</a></p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:PolicyViolationException" class="def">PolicyViolationException</a>  <a href="src/Snap-Util-FileUploads.html#PolicyViolationException" class="link">Source</a></p><div class="subs instances"><p id="control.i:PolicyViolationException" class="caption collapser" onclick="toggleSection('i:PolicyViolationException')">Instances</p><div id="section.i:PolicyViolationException" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Show.html#t:Show">Show</a> <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable">Typeable</a> <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/MonadCatchIO-transformers/latest/doc/html/Control-Monad-CatchIO.html#t:Exception">Exception</a> <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:policyViolationExceptionReason" class="def">policyViolationExceptionReason</a> :: <a href="Snap-Util-FileUploads.html#t:PolicyViolationException">PolicyViolationException</a> -&gt; Text<a href="src/Snap-Util-FileUploads.html#policyViolationExceptionReason" class="link">Source</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.9.2</p></div></body></html>